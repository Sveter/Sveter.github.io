<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LYZ</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-02T15:54:36.263Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李煜哲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux_基础命令</title>
    <link href="http://yoursite.com/2018/09/28/Linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/28/Linux-基础命令/</id>
    <published>2018-09-28T12:48:40.000Z</published>
    <updated>2018-10-02T15:54:36.263Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="Linux-下的基本指令"><a href="#Linux-下的基本指令" class="headerlink" title="Linux 下的基本指令"></a>Linux 下的基本指令</h3><blockquote><p>Linux下一切皆目录</p><p>本文只对一些命令做出图示，其他的还需自行实验</p></blockquote><h4 id="对目录的操作"><a href="#对目录的操作" class="headerlink" title="对目录的操作"></a>对目录的操作</h4><h6 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h6><blockquote><p>语法：ls [选项] [目录或文件]</p><p>功能：列出该目录下的所有子目录与文件</p></blockquote><ul><li>常用选项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些命令可以结合使用</span></span><br><span class="line">ls  -l  <span class="comment">//列出文件的详细信息</span></span><br><span class="line">    -a  <span class="comment">//列出文件目录下的所有文件，包括以.开头的隐藏文件</span></span><br><span class="line">    -d  <span class="comment">//将目录像文件一样显示，而不是显示其下的文件(ls -d 指定目录)</span></span><br><span class="line">    -i  <span class="comment">//输出文件的i节点的索引信息(ls -ai 指定文件)</span></span><br><span class="line">    -k  <span class="comment">//以k字节的形式表示文件的大小</span></span><br><span class="line">    -r  <span class="comment">//对目录反向排序</span></span><br><span class="line">    -t  <span class="comment">//以时间排序</span></span><br><span class="line">    -s  <span class="comment">//在l文件名后输出该文件的大小</span></span><br><span class="line">    -S  <span class="comment">//按文件大小排序</span></span><br><span class="line">    -R  <span class="comment">//列出所有子目录下的文件(递归)</span></span><br><span class="line">    <span class="number">-1</span>  <span class="comment">//一行只输出一个文件</span></span><br></pre></td></tr></table></figure><blockquote><p>ls命令的图示</p></blockquote><p><img src="/img/Linux_BC/1.jpg" alt="avatar"></p><p><img src="/img/Linux_BC/2.jpg" alt="avatar"></p><p><img src="/img/Linux_BC/3.jpg" alt="avatar"></p><p><img src="/img/Linux_BC/4.jpg" alt="avatar"></p><h6 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h6><blockquote><p>功能：显示当前用户所在的目录</p></blockquote><h6 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h6><blockquote><p>功能：在当前目录下创建一个名为“dirname”的目录</p><p>语法：mkdir [选项] dirname</p></blockquote><ul><li>常用选项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./test/test2   <span class="comment">//若创建的目录不存在，递归建立多个目录（从外向内）</span></span><br></pre></td></tr></table></figure><h6 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h6><blockquote><p>rmdir 和 mkdir相对应。</p><p>功能：删除空目录</p><p>语法：rmdir [选项] dirname</p><p>适用对象：具有当前目录操作权限的所有使用者</p></blockquote><ul><li>常用选项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir -p ./test/test2   <span class="comment">//当子目录被删除其父目录也是空目录的话，就连父目录一块删除（从内向外）</span></span><br></pre></td></tr></table></figure><h6 id="su"><a href="#su" class="headerlink" title="su"></a>su</h6><blockquote><p>功能：切换用户</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root  <span class="comment">//切换root用户</span></span><br></pre></td></tr></table></figure><h6 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h6><blockquote><p>功能：改变工作目录(进入指定目录)</p><p>语法：cd 目录名</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ..   <span class="comment">//返回上级目录</span></span><br><span class="line">cd /home/lyz/WorkSpace   <span class="comment">//绝对路径</span></span><br><span class="line">cd ../WorkSpace  <span class="comment">//相对路径</span></span><br><span class="line">cd ~   <span class="comment">//进入用户家目录</span></span><br><span class="line">cd -   <span class="comment">//返回最近访问目录</span></span><br></pre></td></tr></table></figure><p><img src="/img/Linux_BC/5.jpg" alt="avater"></p><blockquote><p>绝对路径和相对路径</p><p>绝对路径：起始查找路径是根目录</p><p>相对路径：起始查找路径是当前目录</p></blockquote><h6 id="根目录下的文件"><a href="#根目录下的文件" class="headerlink" title="根目录下的文件"></a>根目录下的文件</h6><p><img src="/img/Linux_BC/6.jpg" alt="avater"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/bin     <span class="comment">//常用系统命令（touch）</span></span><br><span class="line">/sbin    <span class="comment">//系统管理命令（useradd）</span></span><br><span class="line">/boot    <span class="comment">//启动分区</span></span><br><span class="line">/sys     <span class="comment">//内核参数调整</span></span><br><span class="line">/dev     <span class="comment">//设备文件（sbd插入u盘）</span></span><br><span class="line">/lib     <span class="comment">//32位库文件</span></span><br><span class="line">/lib64   <span class="comment">//64文库文件</span></span><br><span class="line">/media /run /mnt    <span class="comment">//临时设备的挂载点（u盘）</span></span><br><span class="line">/opt     <span class="comment">//第三方软件安装位置</span></span><br><span class="line">/proc    <span class="comment">//系统信息（看进程）</span></span><br><span class="line">/etc     <span class="comment">//系统配置目录</span></span><br><span class="line">/home    <span class="comment">//普通用户家目录</span></span><br><span class="line">/root    <span class="comment">//超级用户家目录</span></span><br><span class="line">/var,/srv    <span class="comment">//系统数据（建立论坛时的数据）</span></span><br></pre></td></tr></table></figure><h6 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h6><blockquote><p>功能：删除文件或目录</p><p>语法：rm [选项] dir/dirname</p><p>适用对象：所有使用者</p></blockquote><ul><li>常用选项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------(在root用户下，建议不要使用)------</span><br><span class="line">rm -f   <span class="comment">//忽略提示信息，强制删除</span></span><br><span class="line">   -r   <span class="comment">//删除所有文件，包含目录型文件</span></span><br><span class="line">   -i   <span class="comment">//删除前逐一询问确认</span></span><br></pre></td></tr></table></figure><h6 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h6><blockquote><p>功能：默认只能拷贝普通文件，拷贝指定文件到指定位置</p><p>语法：cp [选项] 源文件目录 目标文件目录</p></blockquote><ul><li>常用选项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r   <span class="comment">//递归拷贝指定目录下的所有文件</span></span><br><span class="line">   -f   <span class="comment">//忽略提示信息</span></span><br></pre></td></tr></table></figure><h6 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h6><blockquote><p>功能：移动指定文件到指定位置</p><p>语法：mv [选项] 源文件目录 目标文件目录</p></blockquote><ul><li>常用选项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv -f   <span class="comment">//忽略提示信息</span></span><br><span class="line">   -i   <span class="comment">//增加提示信息</span></span><br></pre></td></tr></table></figure><h4 id="对文件的操作"><a href="#对文件的操作" class="headerlink" title="对文件的操作"></a>对文件的操作</h4><h6 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h6><blockquote><p>功能：若文件不存在则创建新文件，存在则刷新时间属性</p><p>语法：touch [选项] 文件</p></blockquote><ul><li>常用选项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch -r 以一个文件的时间属性来刷新另一个文件</span><br><span class="line">  -t 以一个指定的时间来刷新文件的时间属性 （使用 man touch查看时间格式）</span><br></pre></td></tr></table></figure><p><img src="/img/Linux_BC/7.jpg" alt="avater"></p><h6 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h6><blockquote><p>功能：打印文件内容到终端显示</p><p>语法：cat [选项] 文件</p></blockquote><ul><li>常用选项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n   <span class="comment">//显示行号</span></span><br></pre></td></tr></table></figure><h6 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h6><blockquote><p>功能：按行逆序打印文件内容</p></blockquote><h6 id="more"><a href="#more" class="headerlink" title="more"></a>more</h6><blockquote><p>功能：按页显示文件内容</p><p>more [选项] 文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">空格 向下翻页</span><br><span class="line"> b   向上翻页</span><br><span class="line">   回车 按行向下走</span><br><span class="line"> q   退出</span><br></pre></td></tr></table></figure><h6 id="less"><a href="#less" class="headerlink" title="less"></a>less</h6><blockquote><p>功能：按页显示文件内容</p><p>语法：less [选项] 文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   f 空格 pgdown  向下翻页</span><br><span class="line">b pgup 向上翻页</span><br><span class="line">上下 按行走</span><br><span class="line">q 退出</span><br><span class="line">/string 向下匹配字符串</span><br><span class="line">?string 向上匹配字符串</span><br><span class="line">n 重复前一个搜索（/ OR ?）</span><br></pre></td></tr></table></figure><h6 id="head"><a href="#head" class="headerlink" title="head"></a>head</h6><blockquote><p>功能：显示文件的前n行内容（默认10行）</p><p>语法：head [参数] 文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n num  <span class="comment">//指定显示前num行</span></span><br></pre></td></tr></table></figure><h6 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h6><blockquote><p>功能：显示文件的末尾（默认10行）</p><p>语法：tail [参数] 文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   -n num 显示末尾num行</span><br><span class="line">-f 动态刷新显示文件末尾内容，常用于看日志</span><br></pre></td></tr></table></figure><p><img src="/img/Linux_BC/8.jpg" alt="avater"></p><h6 id="压缩操作"><a href="#压缩操作" class="headerlink" title="压缩操作"></a>压缩操作</h6><blockquote><p>压缩/解压缩/打包</p></blockquote><ul><li>压缩/解压缩</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zip/unzip 按zip格式进行压缩/解压缩</span><br><span class="line">zip a.zip a.txt</span><br><span class="line">unzip a.zip</span><br><span class="line"></span><br><span class="line">gzip/gunzip 按gzip格式进行压缩/解压缩</span><br><span class="line">gzip a.txt</span><br><span class="line">gunzip a.txt.gz</span><br><span class="line"></span><br><span class="line">bzip2/bunzip2 按bzip2格式进行压缩/解压缩</span><br><span class="line">bzip2 a.txt</span><br><span class="line">bunzip2 a.txt.bz2</span><br></pre></td></tr></table></figure><ul><li>打包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar 文件打包</span><br><span class="line">-c 打包</span><br><span class="line">-x 解包</span><br><span class="line">-v 显示详细的打包/解包信息</span><br><span class="line">-f 指定包名，所以-f通常是最后一个选项</span><br><span class="line">-z 打包/解包同时以gzip格式  .tar.gz</span><br><span class="line">-j 打包/解包同时以bzip2格式 .tar.bz2</span><br></pre></td></tr></table></figure><h6 id="查找匹配操作命令"><a href="#查找匹配操作命令" class="headerlink" title="查找匹配操作命令"></a>查找匹配操作命令</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find 从指定路径下文件查找</span><br><span class="line">-name 按文件名查找（find 从哪快开始找 -name <span class="string">"文件名"</span>）</span><br><span class="line">-type 按文件类型查找 </span><br><span class="line">-size 按文件大小查找  （+/-n[cwbKMG]）</span><br><span class="line">-amin -atime -mtime -mmin -cmin -ctime 按时间查找文件（min 分钟 time天）</span><br></pre></td></tr></table></figure><p><img src="/img/Linux_BC/9.jpg" alt="avater"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep 字符串内容匹配（从文件内容匹配字符串）</span><br><span class="line">-i 忽略大小进行匹配</span><br><span class="line">-v 反向匹配，匹配的是不包含指定字符串的行</span><br><span class="line">-R 递归在指定目录下的所有文件中进行匹配</span><br></pre></td></tr></table></figure><h6 id="其他操作命令"><a href="#其他操作命令" class="headerlink" title="其他操作命令"></a>其他操作命令</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   echo 将内容写入到文件最后一行</span><br><span class="line">       echo <span class="string">"lyz"</span> &gt;&gt; test.txt</span><br><span class="line">   cal查看日历</span><br><span class="line">默认打印当前月日历</span><br><span class="line">-j按一年中的第几天来显示日历</span><br><span class="line">-y查看全年日历</span><br><span class="line">bc计算器</span><br><span class="line">date显示当前系统时间</span><br><span class="line">+%s显示时间戳（<span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>到现在所经过的秒数）</span><br><span class="line">+'%F %T  %Y-%m-%d %H:%M:%S'  指定格式打印时间</span><br><span class="line">-s设置系统时间“<span class="number">2018</span><span class="number">-09</span><span class="number">-13</span> <span class="number">19</span>:<span class="number">36</span>:<span class="number">23</span>”</span><br><span class="line">halt关机</span><br><span class="line">shutdown -h now关机</span><br><span class="line">reboot重启</span><br></pre></td></tr></table></figure><h4 id="Linux的权限管理"><a href="#Linux的权限管理" class="headerlink" title="Linux的权限管理"></a>Linux的权限管理</h4><h6 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件的权限是针对用户的权限，用户分了三类</span><br><span class="line">    u文件所有者: 这个文件属于谁</span><br><span class="line">    g文件所属组：文件属于哪个用户组（组内成员的权限）</span><br><span class="line">    o其他用户：除了上面两类用户之外的用户</span><br></pre></td></tr></table></figure><h6 id="用户应该对文件具备的的权限"><a href="#用户应该对文件具备的的权限" class="headerlink" title="用户应该对文件具备的的权限"></a>用户应该对文件具备的的权限</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r可读权限：用户是否可以读取这个文件内容</span><br><span class="line">w可写权限：用户是否可以修改这个文件内容</span><br><span class="line">x可执行权限：用户是否可以执行这个文件</span><br></pre></td></tr></table></figure><blockquote><p>权限是针对三类用户，每个用户权限分了三种</p></blockquote><table><thead><tr><th>所有者</th><th>所属组</th><th>其他用户</th></tr></thead><tbody><tr><td>111</td><td>111</td><td>111</td></tr><tr><td>rwx</td><td>rwx</td><td>rwx</td></tr></tbody></table><table><thead><tr><th>操作</th><th>文件</th><th>目录</th></tr></thead><tbody><tr><td>r</td><td>可读</td><td>可浏览</td></tr><tr><td>w</td><td>可写</td><td>可创建/删除</td></tr><tr><td>x</td><td>可执行</td><td>可进入</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个文件所有者可读可写，所属组可读，其他用户无权限</span></span><br><span class="line">rwx rwx rwx ---&gt; <span class="number">111</span> <span class="number">111</span> <span class="number">111</span> ---&gt; <span class="number">777</span></span><br></pre></td></tr></table></figure><h6 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h6><blockquote><p>功能：查看/设置文件的创建权限掩码</p><p>格式：umask 权限值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标准的文件创建是拿给定的权限与一个取反的掩码，得到最终的权限给定权限&amp;(~umask)</span><br><span class="line"></span><br><span class="line">// 我们在shell中创建文件的时候给定的权限是666</span><br><span class="line">// 而shell的掩码是002，因此得到的文件权限是664</span><br><span class="line">// 666 &amp; （~002）</span><br></pre></td></tr></table></figure><h6 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h6><blockquote><p>功能：修改文件权限</p><p>格式：chmod [参数] 权限 文件名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给指定的用户添加/删除指定权限</span><br><span class="line">u/g/o/a +/- r/w/x </span><br><span class="line">chmod +x file</span><br><span class="line">chmod g-x file</span><br><span class="line">以八进制数字来修改</span><br><span class="line">chmod 777  file</span><br><span class="line">//例子</span><br><span class="line">//chmod u-w WorkSpace/test_9_9/test.txt</span><br><span class="line">//chmod 664 WorkSpace/test_9_9/test.txt</span><br></pre></td></tr></table></figure><h6 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h6><blockquote><p>功能：修改文件所有者</p><p>格式：chown 用户名 文件名</p></blockquote><h6 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h6><blockquote><p>功能：修改文件所属组</p><p>格式：chgrp 用户名 文件名</p></blockquote><h6 id="沾滞位"><a href="#沾滞位" class="headerlink" title="沾滞位"></a>沾滞位</h6><blockquote><p>沾滞位这个权限位是主要是针对目录的，对于设置了沾滞位的目录，用户能够创建文件，但是只能删除自己的文件，不能删除别人的文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求：一个目录，是大家公认的目录，然后所有人都可以在目录中创建文件，但是用户只能删除自己文件，不能删除别人文件</span><br></pre></td></tr></table></figure><p><img src="/img/Linux_BC/10.jpg" alt="avater"></p><p><img src="/img/Linux_BC/11.jpg" alt="avater"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Linux-下的基本指令&quot;&gt;&lt;a href=&quot;#Linux-下的基本指令&quot; class=&quot;headerlink&quot; title=&quot;Linux 下的基本指令&quot;&gt;&lt;/a&gt;Linux 下的基本指令&lt;/h3&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>结构体</title>
    <link href="http://yoursite.com/2018/09/09/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2018/09/09/结构体/</id>
    <published>2018-09-09T07:28:40.000Z</published>
    <updated>2018-09-29T06:46:28.099Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li>结构体的声明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct tag  //结构体类型，tag 结构体标签</span><br><span class="line">&#123;</span><br><span class="line">    member-list;</span><br><span class="line">&#125;variable-list;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 特殊的声明：省略结构体标签（tag）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  int a;</span><br><span class="line">  char b;</span><br><span class="line">  float c;</span><br><span class="line">&#125;x;</span><br><span class="line"></span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  int a;</span><br><span class="line">  char b;</span><br><span class="line">  float c;</span><br><span class="line">&#125;a[20],*p;</span><br></pre></td></tr></table></figure><ul><li><p>[ ] 结构体成员</p><blockquote><p>可以是标量、数组、指针，甚至是其它结构体</p></blockquote></li><li><p>[ ] 访问结构体成员</p><blockquote><p>结构体变量访问成员：结构变量的成员是通过点操作符访问的。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Stu</span><br><span class="line">&#123;</span><br><span class="line">  char name[20];</span><br><span class="line">  int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct Stu s;  //定义结构体变量</span><br><span class="line">    strcpy(s.name,&quot;zhangsan&quot;);</span><br><span class="line">    s.age = 20;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结构体访问指针变量的成员</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct S</span><br><span class="line">&#123;</span><br><span class="line">   char name[20];</span><br><span class="line">   int age;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line">void print(struct S* ps)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s %d&quot;,(*ps).name,(*ps).age);</span><br><span class="line">    printf(&quot;%s %d&quot;,ps-&gt;name,ps-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 结构体的自引用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//eg1</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">  int data;</span><br><span class="line">  struct Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//eg2</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">  int data;</span><br><span class="line">  struct Node* next;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 结构的不完整声明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct B；//在A中B还没有定义，所以必须要在A前声明B</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">   int a;</span><br><span class="line">   struct B* pb;</span><br><span class="line">&#125;;</span><br><span class="line">struct B</span><br><span class="line">&#123;</span><br><span class="line">  int b;</span><br><span class="line">  struct A* pa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>结构体变量的定义和初始化</p></li><li><p>[ ] 变量的定义</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">  int x;</span><br><span class="line">  int y;</span><br><span class="line">&#125;p1;  //声明类型同时定义变量p1</span><br><span class="line"></span><br><span class="line">struct Point p2;//定义结构体变量p2</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Stu</span><br><span class="line">&#123;</span><br><span class="line">  char name[15];</span><br><span class="line">  int age;</span><br><span class="line">&#125;;</span><br><span class="line">//初始化</span><br><span class="line">struct Stu s = &#123;&quot;zhangsan&quot;,20&#125;;</span><br><span class="line">//结构体嵌套初始化</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct Stu s;</span><br><span class="line">    struct Node* next;</span><br><span class="line">&#125;n1 = &#123;10,&#123;&quot;lisi&quot;,19&#125;,NULL&#125;;</span><br></pre></td></tr></table></figure><ul><li>结构体传参</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct S</span><br><span class="line">&#123;</span><br><span class="line">    int data[100];</span><br><span class="line">    int num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct S s = &#123;&#123;1,2,3,4&#125;,1000&#125;;</span><br><span class="line">//结构体传参</span><br><span class="line">void print1(struct S s)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;,s.num);</span><br><span class="line">&#125;</span><br><span class="line">//结构体地址传参</span><br><span class="line">void print2(struct S* ps)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;,ps-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    print1(s);</span><br><span class="line">    print2(&amp;s);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函数传参的时候参数是需要压栈的，如果传递结构体对象的时候，结构体过大，压栈时系统开销大，会导致性能下降，所以选择传址</p><ul><li>结构体内存对齐</li></ul></blockquote><blockquote><p>结构体的内存对齐是拿空间换取时间的做法</p><ul><li style="list-style: none"><input type="checkbox"> 结构体的对齐规则</li></ul><ol><li>第一个成员在与结构体变量偏移量为0的地址处</li><li>其他成员变量要对齐到对齐数的整数倍的地址处。对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。VS中默认为8，Linux中默认为4</li><li>结构体总大小为最大对齐数的整数倍</li><li>如果嵌套了结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct S1</span><br><span class="line">&#123;</span><br><span class="line">char c1;</span><br><span class="line">int i;</span><br><span class="line">char c2;</span><br><span class="line">&#125;;</span><br><span class="line">struct S2</span><br><span class="line">&#123;</span><br><span class="line">char c1;</span><br><span class="line">char c2;</span><br><span class="line">int i;</span><br><span class="line">&#125;;</span><br><span class="line">struct S3</span><br><span class="line">&#123;</span><br><span class="line">double d;</span><br><span class="line">char c;</span><br><span class="line">int i;</span><br><span class="line">&#125;;</span><br><span class="line">//结构体的嵌套</span><br><span class="line">struct S4</span><br><span class="line">&#123;</span><br><span class="line">char c1;</span><br><span class="line">struct S3 s3;</span><br><span class="line">double d;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;, sizeof(struct S1));</span><br><span class="line">printf(&quot;%d\n&quot;, sizeof(struct S2));</span><br><span class="line">printf(&quot;%d\n&quot;, sizeof(struct S3));</span><br><span class="line">printf(&quot;%d\n&quot;, sizeof(struct S4));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：image</p><p>这里只对S4进行分析</p><p>如图：</p><blockquote><p>在设计结构体的时候，我们既要满足对其又要节省空间，所以让占用空间小的成员尽量集中在一起</p></blockquote><ul><li>位段</li></ul><blockquote><p>位段的声明与结构体类似，但有两处不同</p><ol><li>位段的成员必须是int、unsigned int、signed int</li><li>位段的成员名后面有一个冒号和一个数字</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    int _a:2;</span><br><span class="line">    int _b:5;</span><br><span class="line">    int _c:10;</span><br><span class="line">    int _d:30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(struct A));  //8</span><br></pre></td></tr></table></figure><blockquote><p>冒号后边的数字为比特位</p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 接下来分析下位段的空间是如何开辟的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct S</span><br><span class="line">&#123;</span><br><span class="line">char a : 3;</span><br><span class="line">char b : 4;</span><br><span class="line">char c : 5;</span><br><span class="line">char d : 4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">struct S s = &#123;0&#125;;</span><br><span class="line">s.a = 10;</span><br><span class="line">s.b = 12;</span><br><span class="line">s.c = 3;</span><br><span class="line">s.d = 4;</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(struct S));//3</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：所示</p><ul><li><p>[ ] 位段的内存分配</p><blockquote><ol><li>位段的成员可以是int、unsigned int、signed int或者是char类型</li><li>位段设计很多不确定因素，且是不跨平台的，注意可移植程序避免使用位段</li></ol></blockquote></li><li><p>[ ] 位段的跨平台问题</p><blockquote><ol><li>int位段被当成有符号还是无符号数不确定</li><li>位段中最大位的数目不确定。（16位机器最大16,32位机器最大32）</li><li>位段中的成员在内存中从左向右还是从右向左分配未定义</li><li>当一个结构包含两个位段，第二个位段成员比较大，无法容纳第一个位段剩余位时，舍弃剩余位还是利用剩余位，不确定</li></ol></blockquote></li></ul><h2 id="枚举（一一列举）"><a href="#枚举（一一列举）" class="headerlink" title="枚举（一一列举）"></a>枚举（一一列举）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Day</span><br><span class="line">&#123;</span><br><span class="line">    //枚举常量</span><br><span class="line">    MON,</span><br><span class="line">    TUE,</span><br><span class="line">    WED,</span><br><span class="line">    THUR,</span><br><span class="line">    FRI,</span><br><span class="line">    SAT,</span><br><span class="line">    SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>枚举常量的值默认从0开始，依次递增1，在定义时也可以赋初值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Color</span><br><span class="line">&#123;</span><br><span class="line">    RED = 1,</span><br><span class="line">    GREEN = 3,</span><br><span class="line">    BLUE = 4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 枚举的优点<blockquote><ol><li>增加代码的可读性和可维护性</li><li>枚举有类型检查，更加严谨（只能拿枚举常量给枚举变量赋值，这样不会出现类型的差异）</li><li>防止命名污染，便与调试，一次可定义多个常量</li></ol></blockquote></li></ul><h2 id="联合（共用体）"><a href="#联合（共用体）" class="headerlink" title="联合（共用体）"></a>联合（共用体）</h2><ul><li style="list-style: none"><input type="checkbox"> 联合类型的定义<blockquote><p>联合类型的定义的成员共用同一块空间</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union Un</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(union Un));//4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//联合的特点：成员共用同一块空间</span><br><span class="line">union Un</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    char c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">union Un un;</span><br><span class="line">printf(&quot;%d\n&quot;,&amp;(un.i));</span><br><span class="line">printf(&quot;%d\n&quot;,&amp;(un.c));</span><br></pre></td></tr></table></figure><p>123</p><ul><li style="list-style: none"><input type="checkbox"> 联合大小的计算<blockquote><ol><li>联合的大小至少是最大成员的大小</li><li>当最大成员大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍</li></ol></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">union U1</span><br><span class="line">&#123;</span><br><span class="line">    char c[5];</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line">union U2</span><br><span class="line">&#123;</span><br><span class="line">    short c[7];</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(union U1));//8</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(union U2));//16</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 联合的一些应用<blockquote><p>判断大小端存储</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int check_sys()</span><br><span class="line">&#123;</span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        char c;</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.i = 1;</span><br><span class="line">    return un.c;</span><br><span class="line">    //返回1小端存储，返回0大端存储</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>联合和结构体的使用（IP地址）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//将long类型的IP地址转换为点分10进制的表示形式</span><br><span class="line">union ip_addr</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long addr;</span><br><span class="line">    struct</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned char c1;</span><br><span class="line">        unsigned char c2;</span><br><span class="line">        unsigned char c3;</span><br><span class="line">        unsigned char c4;</span><br><span class="line">    &#125;ip;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    union ip_addr my_ip;</span><br><span class="line">    my_ip.addr = 123456789;</span><br><span class="line">    printf(&quot;%d.%d.%d.%d\n&quot;,my_ip.ip.c4,my_ip.ip.c3,my_ip.ip.c2,my_ip.ip.c1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;结构体的声明&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>链表的基本操作</title>
    <link href="http://yoursite.com/2018/09/09/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/09/09/链表的基本操作/</id>
    <published>2018-09-09T07:28:40.000Z</published>
    <updated>2018-09-30T07:50:56.014Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote><p>本文中主要分析以下几个链表：</p><p>不带头节点的单链表、带头节点的双向循环链表</p></blockquote><blockquote><h6 id="链表：一种链式存储的线性表，用一组地址任意的存储单元存放线性表的数据元素，称存储单元为一个节点"><a href="#链表：一种链式存储的线性表，用一组地址任意的存储单元存放线性表的数据元素，称存储单元为一个节点" class="headerlink" title="链表：一种链式存储的线性表，用一组地址任意的存储单元存放线性表的数据元素，称存储单元为一个节点"></a>链表：一种链式存储的线性表，用一组地址任意的存储单元存放线性表的数据元素，称存储单元为一个节点</h6></blockquote><h6 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h6><blockquote><p>1.单/双链表</p><p>2.带/不带头节点</p><p>3.循环/不循环链表</p></blockquote><p><img src="/img/List/1.jpg" alt="avatar"></p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><blockquote><h6 id="基本操作：初始化、销毁、插、删、查"><a href="#基本操作：初始化、销毁、插、删、查" class="headerlink" title="基本操作：初始化、销毁、插、删、查"></a>基本操作：初始化、销毁、插、删、查</h6><p>在删除和插入中分：头删/插、尾删/插、正常删/插</p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 定义结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; ListNode;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInit</span><span class="params">(ListNode **ppfirst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(*ppfirst!=<span class="literal">NULL</span>);</span><br><span class="line">    *ppfirst = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 销毁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(ListNode **ppfirst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *next = *ppfirst;</span><br><span class="line">    <span class="keyword">for</span>(ListNode *cur = *ppfirst;cur!=<span class="literal">NULL</span>;cur = next)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    *ppfirst = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 创建节点</li></ul><p><img src="/img/List/2.jpg" alt="avatar"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">CreatNode</span><span class="params">(DateType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* newnode = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    assert(newnode);</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 插入</li></ul><blockquote><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>正常情况：从堆上申请空间，更改ppfirst的值</p><p>特殊情况：*ppfirst == NULL</p></blockquote><ul><li>头插</li></ul><p><img src="/img/List/3.jpg" alt="avatar"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPushFront</span><span class="params">(ListNode **ppfirst, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ppfirst != <span class="literal">NULL</span>);</span><br><span class="line">    ListNode* node = CreatNode(data);</span><br><span class="line">    node-&gt;next = *ppfirst;</span><br><span class="line">    </span><br><span class="line">    *ppfirst = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尾插（遍历链表）</li></ul><p><img src="/img/List/4.jpg" alt="avatar"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPushBack</span><span class="params">(ListNode **ppfirst, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* node = CreatNode(data);</span><br><span class="line">    <span class="comment">//特殊情况 链表为空</span></span><br><span class="line">    <span class="keyword">if</span>(*ppfirst == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *ppfirst = node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常情况</span></span><br><span class="line">    ListNode *cur = *ppfirst;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正常插入（中插）</li></ul><blockquote><h6 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h6><ol><li>如果要插入的位置是第一个节点—&gt;调用头插</li><li>找到要插入的位置的前一个节点，插入</li></ol></blockquote><p><img src="/img/List/5.jpg" alt="avatar"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert</span><span class="params">(ListNode **ppfirst, ListNode *pos, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//pos是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(*ppfirst == pos)</span><br><span class="line">    &#123;</span><br><span class="line">        ListPushFront(ppfirst,data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到pos前一个节点</span></span><br><span class="line">    ListNode *cur = *ppfirst;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next != pos)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *node = CreatNode(data);</span><br><span class="line">    node-&gt;next = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>[ ] 删除</p></li><li><p>头删</p></li></ul><blockquote><h6 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h6><ol><li>变量地址不为空</li><li>不能为空链表</li></ol></blockquote><p><img src="/img/List/6.jpg" alt="avatar"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPopFront</span><span class="params">(ListNode **ppfirst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ppfirst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(*ppfirst != <span class="literal">NULL</span>);</span><br><span class="line">    ListNode *del = *ppfirst;</span><br><span class="line">    *ppfirst = del-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(del);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尾删</li></ul><blockquote><h6 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h6><ol><li>cur-&gt;next-&gt;next == NULL</li><li>特殊：只有一个节点</li></ol></blockquote><p><img src="/img/List/7.jpg" alt="avatar"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListPopBack</span><span class="params">(ListNode **ppfirst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ppfirst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(*ppfirst != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>((*ppfirst)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(*ppfirst);</span><br><span class="line">        *ppfirst = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *cur = *ppfirst;</span><br><span class="line">    ListNode *del;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next-&gt;next != <span class="literal">NULL</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    del = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(del);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 正常删除（中删）</li></ul><blockquote><h6 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h6><ol><li>当要删除的是第一个节点时—&gt;头删</li><li>先找到要删除的节点的前一个节点，然后删除</li></ol></blockquote><p><img src="/img/List/8.jpg" alt="avatar"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListEarse</span><span class="params">(ListNode **ppfirst, ListNode *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ppfirst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(*ppfirst != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>((*ppfirst)-&gt;next == pos)</span><br><span class="line">    &#123;</span><br><span class="line">        ListPopFront(ppfirst);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *cur = *ppfirst;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next != pos)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = pos-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 查找</li></ul><blockquote><h6 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h6><ol><li>遍历链表</li><li>传值</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ListFind</span><span class="params">(ListNode* first, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(first);</span><br><span class="line">    <span class="keyword">for</span>(ListNode *cur = first; cur != <span class="literal">NULL</span>; cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;data == data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向带头循环链表"><a href="#双向带头循环链表" class="headerlink" title="双向带头循环链表"></a>双向带头循环链表</h3><blockquote><h6 id="基本操作：初始化、销毁（删除带头节点）、清空（保留带头节点）、插、删"><a href="#基本操作：初始化、销毁（删除带头节点）、清空（保留带头节点）、插、删" class="headerlink" title="基本操作：初始化、销毁（删除带头节点）、清空（保留带头节点）、插、删"></a>基本操作：初始化、销毁（删除带头节点）、清空（保留带头节点）、插、删</h6><p>在删除和插入中分：头删/插、尾删/插、正常删/插</p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 定义结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DListNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DListNode;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 初始化<br><img src="/img/List/9.jpg" alt="avatar"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListInit</span><span class="params">(DListNode **ppHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ppHead != <span class="literal">NULL</span>);</span><br><span class="line">    DListNode *pHead = (DListNOde*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DListNode));</span><br><span class="line">    pHead-&gt;prev = pHead;</span><br><span class="line">    pHead-&gt;next = pHead;</span><br><span class="line">    </span><br><span class="line">    *ppHead = pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 清空链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListClear</span><span class="params">(DListNode *pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DListNode *cur = pHead-&gt;next;</span><br><span class="line">    DListNode *next;</span><br><span class="line">    <span class="keyword">while</span>(cur != pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    pHead-&gt;next = pHead;</span><br><span class="line">pHead-&gt;prev = pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> 销毁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListDestroy</span><span class="params">(DListNode **ppHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(ppHead != <span class="literal">NULL</span>);</span><br><span class="line">    DListClear(*ppHead);</span><br><span class="line">    <span class="built_in">free</span>(*ppHead);</span><br><span class="line">    *ppHead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>[ ] 插入</p></li><li><p>正常插入<br><img src="/img/List/10.jpg" alt="avatar"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListInsert</span><span class="params">(DListNode *pHead, DListNode *pos, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)pHead;<span class="comment">//仅仅是为了防止编译警告</span></span><br><span class="line">    DListNode *node = (DListNOde*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DListNode));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    </span><br><span class="line">    node-&gt;prev = pos-&gt;prev;</span><br><span class="line">node-&gt;next = pos;</span><br><span class="line">pos-&gt;prev-&gt;next = node;</span><br><span class="line">pos-&gt;prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头插</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPushFront</span><span class="params">(DListNode *pHead, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DListInsert(pHead, pHead-&gt;next, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尾插</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPushBack</span><span class="params">(DListNode *pHead, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DListInsert(pHead,pHead,data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>[ ] 删除<br><img src="/img/List/11.jpg" alt="avatar"></p></li><li><p>正常删除</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListErase</span><span class="params">(DListNode *pHead, DListNode *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)pHead;</span><br><span class="line">    assert(pHead != <span class="literal">NULL</span>);</span><br><span class="line">    pos-&gt;prev-&gt;next = pos-&gt;next;</span><br><span class="line">    pos-&gt;next-&gt;prev = pos-&gt;prev;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头删</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPopFront</span><span class="params">(DListNode *pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DListErase(pHead,pHead-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尾删</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DListPopBack</span><span class="params">(DListNode *pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DListErase(pHead, pHead-&gt;prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文中主要分析以下几个链表：&lt;/p&gt;
&lt;p&gt;不带头节点的单链表、带头节点的双向
      
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
