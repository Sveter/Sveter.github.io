<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux_进程概念]]></title>
    <url>%2F2018%2F11%2F24%2FLinux-%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[进程概念进程初识 什么是进程 进程就是运行起来的程序:一个具有一定独立功能的程序在数据集合上的一次动态执行过程 每个进程都有自己的状态 每个进程都有自己的虚拟地址空间 进程是操作系统分配资源的基本单位 如何管理进程 操作系统要对进程进行管理 操作系统对进程的描述：PCB(进程控制块)，在Linux下面叫task_struct PCB(进程控制块) 进程信息被放在一个叫进程控制块的数据结构中，Linux中的PCB是：task_struct，它里面包含着进程的信息，并且会被装载到RAM内存中 task_struct的源码参考：https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h 操作系统对进程的详细描述 1234567891011标识符（pid）：描述本进程的唯一标识符，用来区别其他进程状态：任务状态，退出代码，退出信号等内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块指针I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和被进程使用文件列表记账信息：可能包括处理时间总和，使用的时钟数总和、时间限制、记帐号等优先级：相对于其他进程的优先级多任务，多用户操作系统分时机制---时间片多个进程在CPU上进行切换运行： 程序计数器----用于保存程序运行的下一条指令 上下文数据----用于保存进程切换时寄存器上的数据 如何查看一个进程 查看一个进程 123456 可以通过 /proc 系统文件查看 ps -ef 查看进程信息ps aux 显示信息更全面(所有进程)ps aux | grep top 查看系统资源getpid() 这是一个系统调用接口，在代码中获取进程pid 通过系统调用接口获取pid(进程ID)和ppid(父进程ID) 123456789101112131415161718/*调用函数所要的头文件，和函数接口 #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; pid_t getpid(void); pid_t getppid(void);*/#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;int main()&#123; printf("get pid:%d\n",getpid()); printf("get ppid:%d\n",getppid()); return 0;&#125; 如何创建一个进程 创建一个进程的一般步骤 分配一个PID（从小到大找第一个没有被使用的ID） 分配PCB，拷贝父进程的PCB的绝大部分数据 给子进程分配资源 复制父进程地址空间 将子进程制成就绪状态放入就绪队列 调用pid_t fork(viod)函数 返回值：父进程来说，返回值是子进程的pid，对于子进程来说，返回值是0 1234567891011121314151617181920212223242526//这是一个创建一个进程的代码//调用fork()函数#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;int main()&#123; pid_t pid = fork(); if(pid &lt; 0) &#123; printf("fork error\n"); return -1; &#125; else if(pid == 0)&#123; printf("this is child %d\n",getpid()); &#125; else&#123; printf("this is parent %d, child:%d\n", getpid(),pid); &#125; printf("pid : %d\n",pid); while(1)&#123; sleep(1); &#125; return 0;&#125; 使用fork系统调用通过复制调用进程来创建一个子进程，调用进程我们称之为父进程，创建出来的新进程称之为子进程 因为子进程是以父进程为模板来创建的，因此父子进程的代码段是完全一样的，也就是说，他们运行的程序是一样的 父子进程返回值不同，父子进程共用同一个代码段，但是他们的数据并不共用 我们用户就是通过对返回值的判断来分辨父子进程，来进行代码分流 fork产生新任务的速度非常快，因为fork与原任务共享一个写时复制的内存空间 所谓写时复制就是两个任务可以同时自由的读取内存，但任意一个试图对内存进行修改时，内存就会复制一份提供给修改方单独使用 进程状态 字母 状态 R 运行状态(running) S 睡眠状态(sleeping)可中断睡眠态 D 磁盘睡眠状态(disk sleep)不可中断睡眠态 T 停止状态(stopped) t 追踪态(tracing stop) X 死亡状态(dead) Z 僵尸状态(zombie) 僵尸进程 产生原因：子进程先于父进程退出，他要保留退出原因在PCB中，因此退出后不会释放所有资源，子进程退出后操作系统会通知父进程这个家属说子进程退出了，你去获取以下原因，然后完全释放资源。假如父进程不管子进程的退出状态，那么这个子进程将进入僵死状态，成为僵尸进程。 危害：资源泄露。 12345678910111213141516171819202122232425//实现一个僵尸进程，十秒之后子进程退出//僵尸进程：子进程先于父进程结束#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;error.h&gt;#include &lt;stdlib.h&gt;int main()&#123; pid_t pid = fork(); if(pid &lt; 0)&#123; perror("fork filed:"); return -1; &#125; else if(pid == 0)&#123; printf("this is child!!!\n"); sleep(10); exit(EXIT_SUCCESS); &#125; else&#123; printf("this is parent~~!~~~~\n"); while(1)&#123;&#125; &#125;&#125; 12//用一个脚本文件来观察僵尸进程的产生while :; do ps aux|grep zombie | grep -v grep;sleep 1; echo &quot;#######################&quot;;done 僵尸进程是不能用kill被杀死的，从系统中移除其的唯一方法就是杀掉他们的父进程（或等待其父进程终止），此时1号进程(init)将接管和等待这些僵尸进程，将它们清除掉。 当创建的僵尸进程过多的时候会导致以下问题： 造成内存资源的浪费 内存泄漏 维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，僵尸状态一直不退出，PCB一直都要维护 孤儿进程 父进程先于子进程退出，那么子进程将成为孤儿进程，并进入后台运行。 父进程变为init进程，也就是说子进程后来退出了，init进程将负责释放资源，init进程非常负责任，因此进程不会成为僵尸进程 123456789101112131415161718192021222324252627//实现一个孤儿进程//孤儿进程：父进程先于子进程退出#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;error.h&gt;int main()&#123; pid_t pid = fork(); if(pid &lt; 0)&#123; printf("fork error:"); return -1; &#125; else if(pid == 0)&#123; printf("this is child！！！\n"); sleep(15); printf("init get child!!!\n"); &#125; else&#123; printf("i am parent~~~~~~~~\n"); sleep(5); exit(EXIT_SUCCESS); &#125; return 0;&#125; 进程优先级 [ ] 为什么要有进程优先级？ 因为进程的功能各有不同，因此对CPU资源的要求也各有不同，因此针对进程的调度就有了优先级，优先级决定了CPU资源的优先分配权 PRI：进程可被执行的优先级，其值越小越早被执行 PRI = PRI + NI(进程的nice值) 修改进程优先级的命令：nice/renice 通过设置NI的值来修改进程的优先级 nice取值范围：-20-19，总共40个级别 用top命令来更改已存在的nice：top命令–&gt;”r”–&gt;输入PID–&gt;输入nice值 其它概念 简介 竞争性 系统进程数目众多，而CPU资源只有少量,甚至至1个,所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级 独立性 多进程运行，需要独享各种资源，多进程运行期间互不干扰 并行 多个进程在多个CPU下分别同时运行，这称之为并行 并发 多个进程在一个CPU下采用进程切换的方式，在一段时间内让多个进程都得以推进，称之为并发 环境变量 功能：用于在操作系统中设置环境参数的一些变量 特性：这些环境变量具有全局特性 环境变量相关命令： env 显示所有环境变量 echo $NAME 显示某一个环境变量 export 设置环境变量 set 查看环境变量更加详细 unset 取消一个环境变量 获取环境变量： extern char **environ; main函数第三个参数 getenv(“PATH”); 123456789101112131415161718192021222324252627282930313233343536//获取环境变量的三种方式#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;//方式一：通过全局变量int main()&#123; extern char** environ; int i; for(i = 0;environ[i] != NULL; i++)&#123; printf("env:[%s]\n",environ[i]); &#125; return 0;&#125;//方式二：通过main函数的第三个参数int main(int argc, char* argv[], char* env[])&#123; int i = 0; for(i = 0; env[i] != NULL; i++)&#123; printf("ENV:[%s]\n",env[i]); &#125; return 0;&#125;//方式三：通过系统调用获取指定的环境变量int main()&#123; //char* getenv(const char* name); char* path = getenv("PATH"); printf("env:[%s]\n",path); return 0;&#125; 本地变量和环境变量： 本地变量只能在当前进程使用，不能在子进程中使用 父进程定义的环境变量能在当前进程和子进程中使用 子进程定义的环境变量只能在子进程使用，不能在父进程中使用 程序地址空间12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int val = 100;int main()&#123; int pid = fork(); if (pid &lt; 0) &#123; return -1; &#125;else if (pid == 0) &#123; val = 200; printf("child val:%d ---%p\n", val, &amp;val); &#125;else &#123; sleep(1); printf("parent val:%d ---%p\n", val, &amp;val); &#125; return 0;&#125; 通过结果中打印的地址相同，我们可以推断出：打印出的地址都是虚拟地址 程序地址空间 —&gt;进程地址空间 —&gt;虚拟地址空间 程序地址空间：进程的虚拟地址空间 地址：指向内存区域的一个编号 虚拟地址空间： mm_struct这个结构体描述出了虚拟地址空间 我们获取到的地址都是虚拟地址，不是真正的物理内存地址 虚拟地址是通过页表转换映射之后得到物理内存地址进而访问到内存的让我们进程独立起来 页表：记录虚拟地址和物理地址的转换关系 页表还具有内存访问控制的限制 页表中还记录了要访问的这块地址的属性 内存访问控制：通过对虚拟地址的权限标志来实现对内存的访问控制 MMU：内存管理单元 写时拷贝技术（父进程创建子进程） 进程调度 进程调度调度的是基于PCB调度的 常见的调度算法 调度算法 概要 先来先服务(First Come First Service，FCFS)调度算法 按照进程进入就绪队列的先后顺序选择可以占用处理器的进程。这是一种不可抢占方式的调度算法，优点是实现简单，缺点是后来的进程等待CPU的时间较长。它现今主要用作辅助调度法；例如结合在优先级调度算法中使用，当有两个最高优先级的进程时，则谁先来，谁就先被调度。 短作业(进程)优先调度算法SJ(P)F 是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。 高优先权优先调度 为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。 高响应比优先调度算法 为了弥补短作业优先算法的不足，我们引入动态优先权，使作业的优先等级随着等待时间的增加而以速率a提高。 该优先权变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间；即 =（响应时间）/要求服务时间。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。 基于时间片的轮转调度算法 时间片轮转法一般用于进程调度，每次调度，把CPU分配队首进程，并令其执行一个时间片。 当执行的时间片用完时，由一个记时器发出一个时钟中断请求，该进程被停止，并被送往就绪队列末尾；依次循环。 多级反馈队列调度算法 将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。 多级反馈队列调度算法实施过程 设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中， 为每个进程所规定的执行时间片就越小。 当一个新进程进入内存后，首先放入第一队列的末尾，按FCFS原则排队等候调度。 如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，在同样等待调度…… 如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1到第（i-1）队列空时， 才会调度第i队列中的进程运行，并执行相应的时间片轮转。 如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列， 则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux_常用工具]]></title>
    <url>%2F2018%2F10%2F04%2FLinux-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Linux下的常用工具 我在这里找到了一个linux命令查询的网站：http://man.linuxde.net/ 编辑器 编辑器 特点 ed 行编辑器使用起来很不方便，每次只能对一行进行操作 pico pico很象DOS下的edit程序，打开之后，屏幕下方有操作的提示信息，功能简单，也可以完成操作，一步一步做就可以了。pico的功能键直接列在屏幕的最下方，可以做为帮助来指导操作。 emacs 可以在emacs中进行文本编辑，也可以编写程序代码，做程序调试，编辑HTML/SGML，读News，收发e-mail…，而且emacs经过配置后还支持中文。强大往往意味着操作方法的复杂，emacs也是如此，必须记非常多的命令才能使用它。 vi/vim vim与vi相比，增加了更多的特性，如彩色与高亮显示，可以使我们的编辑工作更轻松。 我们主要对vim进行学习 vim的基本概念 vim 有12种模式，每一种模式都有不同的功能，不同的模式做不同的操作 我们主要掌握三种模式：普通模式、插入模式、底行模式（视图模式、替换模式） vim操作 从普通模式切换到插入模式的方法 12345678i：从光标所在位置开始插入a：从光标所在位置的下一个字符开始插入I：将光标移动到行首，然后进入插入模式A：将光标移动到行尾，然后进入插入模式o：将光标所在行的下方，新建一行，进入插入模式O：将光标所在行的上方，新建一行，进入插入模式s：删除光标所在字符，然后进入插入模式 从普通模式切换到底行模式 123&apos;shift&apos; + &apos;:&apos; w保存，q退出，q!强制退出(不保存本次修改)，wq保存并退出!pwd 临时执行命令，按回车返回vim [ ] 从插入模式/底行模式返回普通模式: ==ESC== [ ] 普通模式下的操作 123456789101112131415161718192021222324h：向左移动光标j：向下移动光标k：向上移动光标l：向右移动光标w：光标向右移动一个单词b：光标向左移动一个单词yy：复制光标所在行nyy：从光标所在行开始向下复制n行p：向光标所在行下方粘贴P：向光标所在行上方粘贴dd：删除光标所在行（vim中删除其实是剪贴）ndd：从光标所在行开始向下删除n行x：删除光标所在字符dw：删除光标所在位置开始的一个单词u：撤销操作Ctrl+r：返回撤销操作Ctrl+v：进入列视图模式，可以进行选择操作v：进入行视图模式r：替换光标所在字符R：进入替换模式，对内容一直替换gg：光标移动到文档的首行G：光标移动到文档的首行gg=G：全文缩进对齐 vim的配置 参考链接：https://www.linuxidc.com/Linux/2016-05/131824.htm 编译器 Linux 下可用的编译器有 GCC、EGCS 和 PGCC，其中最常用的编译器便是 GCC gcc linux下程序的执行就是告诉操作系统程序文件在哪个路径下 gcc是一个编译工具，将我们所写的C语言程序编程成为机器可识别的语言程序 gcc常用选项 12345-o：指定要生成的文件的名称-E：只预处理-S：只编译-c：只汇编-static 静态链接（默认动态） 程序的编译过程==预处理==–&gt;==编译==–&gt;==汇编==–&gt;==链接== 1234567891. 预处理 gcc -E test.c -o test.i 去掉注释展开所有代码2. 编译 gcc -S test.i -o test.s 先纠错，没有错误则编译成为汇编代码3. 汇编 gcc -c test.s -o test.o 将汇编代码生成一个机器可识别代码（汇编只是将我们写的代码编译完毕，但是不能运行， 因为代码不完全，我们调用的一些库函数，并不知道如何实现，需要经过第四步才能生成可执行程序）4. 链接 gcc test.o -o test.exe 将库中的函数链接过来和我们的代码最终合并生成可执行程序 动态链接和静态链接 12345动态链接：链接的是动态库静态链接：链接的是静态库动态链接生成的可执行程序小，静态链接大，但是动态链接生成的程序运行时需要动态库的存在静态库不需要（因为静态链接就是将库中的函数全部拿过来生成可执行程序了，所以大）程序的连接方式默认是动态链接 安装yum yum是红帽系列linux操作系统进行软件包管理的工具，软件的安装、移除、查看都是通过yum工具完成的 12345查看：yum list | grep 想要安装的包名字安装：yum install 想要安装的包名字移除：yum remove 安装包名字修改更新yum源的方法 /etc/yum.repos.d/CentOS-Base.repo rpm12345查看：rpm -a | grep &quot;软件或者包的名字&quot;安装：rpm -i 需要安装的包文件名升级：rpm -U 需要升级的包卸载：rpm -e 需要卸载的安装包卸载之前，通常需要使用rpm -q …命令查出需要卸载的安装包名称 源码安装 源码安装大致可以分为三步骤： （./configure）–＞ 编译（sudo make） –＞ 安装（sudo make install） 1、配置：这是编译源代码的第一步，通过 ./configure 命令完成。 执行此步以便为编译源代码作准备。常用的选项有 –prefix=PREFIX， 用以指定程序的安装位置。更多的选项可通过 –help 查询。也有某些程序无需执行此步。 2、编译：一旦配置通过，可即刻使用 make 指令来执行源代码的编译过程。 视软件的具体情况而定，编译所需的时间也各 有差异，我们所要做的就是耐心等候和静观其变。 此步虽然仅下简单的指令，但有时候所遇到的问题却十分复杂。 较常碰到的情形是程序编译到中途却无法圆满结 束。 此时，需要根据出错提示分析以便找到应对之策。 3、安装：如果编译没有问题，那么执行 sudo make install 就可以将程序安装到系统中了。 安装 介绍 rpm rpm是由红帽公司开发的软件包管理方式，使用rpm我们可以方便的进行软件的安装、查询、卸载、升级等工作。但是rpm软件包之间的依赖性问题往往会很繁琐,尤其是软件由多个rpm包组成时。 yum Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 makefile 在makefile中我们通常定义很多的程序编译规则，在终端命令行下敲击一个make命令，那么这个时候make这个程序，就会跑到当前目录下找寻这个Makefile文件，然后按照makefie中已经规划好的编译顺序以及编译规则来完成整个项目的编译 make命令 只在当前目录下找名字为Makefile/makefile的文件 make可以检测目标对象与依赖对象的时间属性，判断程序是否需要重新编译（一个目标对象是否重新生成） 永远之找第一个目标对象生成，生成了第一个对象之后就退出了 make可以指定要生成的对象 ，例如make clean 伪对象 不管是不是最新的都需要重新生成（执行下边的生成命令） 使用 ==.PHONY== 来声明一个对象是伪对象 变量 预定义变量—Makefile中已经提前定义好的变量 $@ 编写规则中要生成的目标对象 $^ 编写规则中所有的依赖对象 $&lt; 编写规则中第一个依赖对象 wildcard关键字用于获取文件名 a=$(src),变量的使用需要加上一个$符号，否则认为是字符串赋值 如何编写makefile 12目标对象名称：依赖对象名称[制表符]通过依赖对象生成目标对象的命令 gdb使用 gcc -g gcc -g 选项是开启gdb调试选项，目的是为了在可执行程序中加入调试符号信息 gdb调试一个程序需要这个程序在编译时加上-g选项来开启调试，为可执行程序加入一些调试符号信息。例如：gcc -g main.c -o main gdb如何加载程序 gdb ./main 或者 gdb进入之后 file ./main gdb常用命令 1234567891011121314151617181920q 退出run/r 开始运行程序，程序直接跑起来 r -l -s -a 程序的参数在这里加载start 开始逐步调试程序list/l 查看当前行附近代码next/n 下一步，不跟踪进入函数until n 直接运行到第n行b 添加断点 eg: b main.c:n 给main.c第n行添加断点 b n 给当前文件第n行添加断点 b func 给函数添加断点s 下一步，跟踪进入函数i 查看详细信息 i b 查看当前断点信息d 默认删除所有断点 d n 删除id 为n的断点p 打印变量内容（p i(变量)）watch 变量监控,变量修改后会停下来（watch i(变量)）c 继续运行bt 查看函数调用栈]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux_基础命令]]></title>
    <url>%2F2018%2F09%2F28%2FLinux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux 下的基本指令 Linux下一切皆目录 本文只对一些命令做出图示，其他的还需自行实验 对目录的操作ls 语法：ls [选项] [目录或文件] 功能：列出该目录下的所有子目录与文件 常用选项 123456789101112//这些命令可以结合使用ls -l //列出文件的详细信息 -a //列出文件目录下的所有文件，包括以.开头的隐藏文件 -d //将目录像文件一样显示，而不是显示其下的文件(ls -d 指定目录) -i //输出文件的i节点的索引信息(ls -ai 指定文件) -k //以k字节的形式表示文件的大小 -r //对目录反向排序 -t //以时间排序 -s //在l文件名后输出该文件的大小 -S //按文件大小排序 -R //列出所有子目录下的文件(递归) -1 //一行只输出一个文件 ls命令的图示 pwd 功能：显示当前用户所在的目录 mkdir 功能：在当前目录下创建一个名为“dirname”的目录 语法：mkdir [选项] dirname 常用选项 1mkdir -p ./test/test2 //若创建的目录不存在，递归建立多个目录（从外向内） rmdir rmdir 和 mkdir相对应。 功能：删除空目录 语法：rmdir [选项] dirname 适用对象：具有当前目录操作权限的所有使用者 常用选项 1rmdir -p ./test/test2 //当子目录被删除其父目录也是空目录的话，就连父目录一块删除（从内向外） su 功能：切换用户 1su root //切换root用户 cd 功能：改变工作目录(进入指定目录) 语法：cd 目录名 12345cd .. //返回上级目录cd /home/lyz/WorkSpace //绝对路径cd ../WorkSpace //相对路径cd ~ //进入用户家目录cd - //返回最近访问目录 绝对路径和相对路径 绝对路径：起始查找路径是根目录 相对路径：起始查找路径是当前目录 根目录下的文件 1234567891011121314/bin //常用系统命令（touch）/sbin //系统管理命令（useradd）/boot //启动分区/sys //内核参数调整/dev //设备文件（sbd插入u盘）/lib //32位库文件/lib64 //64文库文件/media /run /mnt //临时设备的挂载点（u盘）/opt //第三方软件安装位置/proc //系统信息（看进程）/etc //系统配置目录/home //普通用户家目录/root //超级用户家目录/var,/srv //系统数据（建立论坛时的数据） rm 功能：删除文件或目录 语法：rm [选项] dir/dirname 适用对象：所有使用者 常用选项 1234------(在root用户下，建议不要使用)------rm -f //忽略提示信息，强制删除 -r //删除所有文件，包含目录型文件 -i //删除前逐一询问确认 cp 功能：默认只能拷贝普通文件，拷贝指定文件到指定位置 语法：cp [选项] 源文件目录 目标文件目录 常用选项 12rm -r //递归拷贝指定目录下的所有文件 -f //忽略提示信息 mv 功能：移动指定文件到指定位置 语法：mv [选项] 源文件目录 目标文件目录 常用选项 12mv -f //忽略提示信息 -i //增加提示信息 对文件的操作touch 功能：若文件不存在则创建新文件，存在则刷新时间属性 语法：touch [选项] 文件 常用选项 12touch -r 以一个文件的时间属性来刷新另一个文件 -t 以一个指定的时间来刷新文件的时间属性 （使用 man touch查看时间格式） cat 功能：打印文件内容到终端显示 语法：cat [选项] 文件 常用选项 1cat -n //显示行号 tac 功能：按行逆序打印文件内容 more 功能：按页显示文件内容 more [选项] 文件 1234空格 向下翻页 b 向上翻页 回车 按行向下走 q 退出 less 功能：按页显示文件内容 语法：less [选项] 文件 1234567 f 空格 pgdown 向下翻页b pgup 向上翻页上下 按行走q 退出/string 向下匹配字符串?string 向上匹配字符串n 重复前一个搜索（/ OR ?） head 功能：显示文件的前n行内容（默认10行） 语法：head [参数] 文件 1head -n num //指定显示前num行 tail 功能：显示文件的末尾（默认10行） 语法：tail [参数] 文件 12 -n num 显示末尾num行-f 动态刷新显示文件末尾内容，常用于看日志 压缩操作 压缩/解压缩/打包 压缩/解压缩 1234567891011zip/unzip 按zip格式进行压缩/解压缩 zip a.zip a.txt unzip a.zipgzip/gunzip 按gzip格式进行压缩/解压缩 gzip a.txt gunzip a.txt.gzbzip2/bunzip2 按bzip2格式进行压缩/解压缩 bzip2 a.txt bunzip2 a.txt.bz2 打包 1234567tar 文件打包 -c 打包 -x 解包 -v 显示详细的打包/解包信息 -f 指定包名，所以-f通常是最后一个选项 -z 打包/解包同时以gzip格式 .tar.gz -j 打包/解包同时以bzip2格式 .tar.bz2 查找匹配操作命令12345find 从指定路径下文件查找 -name 按文件名查找（find 从哪快开始找 -name "文件名"） -type 按文件类型查找 -size 按文件大小查找 （+/-n[cwbKMG]） -amin -atime -mtime -mmin -cmin -ctime 按时间查找文件（min 分钟 time天） 1234grep 字符串内容匹配（从文件内容匹配字符串） -i 忽略大小进行匹配 -v 反向匹配，匹配的是不包含指定字符串的行 -R 递归在指定目录下的所有文件中进行匹配 其他操作命令1234567891011121314 echo 将内容写入到文件最后一行 echo "lyz" &gt;&gt; test.txt cal 查看日历 默认打印当前月日历 -j 按一年中的第几天来显示日历 -y 查看全年日历bc 计算器date 显示当前系统时间 +%s 显示时间戳（1970-01-01 00:00:00到现在 所经过的秒数） +'%F %T %Y-%m-%d %H:%M:%S' 指定格式打印时间 -s 设置系统时间“2018-09-13 19:36:23”halt 关机shutdown -h now 关机reboot 重启 Linux的权限管理文件权限管理1234文件的权限是针对用户的权限，用户分了三类 u 文件所有者: 这个文件属于谁 g 文件所属组：文件属于哪个用户组（组内成员的权限） o 其他用户：除了上面两类用户之外的用户 用户应该对文件具备的的权限123r 可读权限：用户是否可以读取这个文件内容w 可写权限：用户是否可以修改这个文件内容x 可执行权限：用户是否可以执行这个文件 权限是针对三类用户，每个用户权限分了三种 所有者 所属组 其他用户 111 111 111 rwx rwx rwx 操作 文件 目录 r 可读 可浏览 w 可写 可创建/删除 x 可执行 可进入 12//一个文件所有者可读可写，所属组可读，其他用户无权限rwx rwx rwx ---&gt; 111 111 111 ---&gt; 777 umask 功能：查看/设置文件的创建权限掩码 格式：umask 权限值 12345标准的文件创建是拿给定的权限与一个取反的掩码，得到最终的权限给定权限&amp;(~umask)// 我们在shell中创建文件的时候给定的权限是666// 而shell的掩码是002，因此得到的文件权限是664// 666 &amp; （~002） chmod 功能：修改文件权限 格式：chmod [参数] 权限 文件名 123456789给指定的用户添加/删除指定权限 u/g/o/a +/- r/w/x chmod +x file chmod g-x file 以八进制数字来修改 chmod 777 file//例子//chmod u-w WorkSpace/test_9_9/test.txt//chmod 664 WorkSpace/test_9_9/test.txt chown 功能：修改文件所有者 格式：chown 用户名 文件名 chgrp 功能：修改文件所属组 格式：chgrp 用户名 文件名 沾滞位 沾滞位这个权限位是主要是针对目录的，对于设置了沾滞位的目录，用户能够创建文件，但是只能删除自己的文件，不能删除别人的文件 1需求：一个目录，是大家公认的目录，然后所有人都可以在目录中创建文件，但是用户只能删除自己文件，不能删除别人文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体]]></title>
    <url>%2F2018%2F09%2F09%2F%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[结构体 结构体的声明 1234struct tag //结构体类型，tag 结构体标签&#123; member-list;&#125;variable-list; 特殊的声明：省略结构体标签（tag） 12345678910111213struct&#123; int a; char b; float c;&#125;x;struct&#123; int a; char b; float c;&#125;a[20],*p; [ ] 结构体成员 可以是标量、数组、指针，甚至是其它结构体 [ ] 访问结构体成员 结构体变量访问成员：结构变量的成员是通过点操作符访问的。 12345678910111213struct Stu&#123; char name[20]; int age;&#125;;int main()&#123; struct Stu s; //定义结构体变量 strcpy(s.name,&quot;zhangsan&quot;); s.age = 20; return 0;&#125; 结构体访问指针变量的成员 1234567891011struct S&#123; char name[20]; int age;&#125;s;void print(struct S* ps)&#123; printf(&quot;%s %d&quot;,(*ps).name,(*ps).age); printf(&quot;%s %d&quot;,ps-&gt;name,ps-&gt;age);&#125; 结构体的自引用 12345678910111213//eg1struct Node&#123; int data; struct Node* next;&#125;;//eg2typedef struct Node&#123; int data; struct Node* next;&#125;Node; 结构的不完整声明 1234567891011struct B；//在A中B还没有定义，所以必须要在A前声明Bstruct A&#123; int a; struct B* pb;&#125;;struct B&#123; int b; struct A* pa;&#125;; 结构体变量的定义和初始化 [ ] 变量的定义 1234567struct Point&#123; int x; int y;&#125;p1; //声明类型同时定义变量p1struct Point p2;//定义结构体变量p2 初始化 1234567891011121314struct Stu&#123; char name[15]; int age;&#125;;//初始化struct Stu s = &#123;&quot;zhangsan&quot;,20&#125;;//结构体嵌套初始化struct Node&#123; int data; struct Stu s; struct Node* next;&#125;n1 = &#123;10,&#123;&quot;lisi&quot;,19&#125;,NULL&#125;; 结构体传参 123456789101112131415161718192021222324struct S&#123; int data[100]; int num;&#125;;struct S s = &#123;&#123;1,2,3,4&#125;,1000&#125;;//结构体传参void print1(struct S s)&#123; printf(&quot;%d\n&quot;,s.num);&#125;//结构体地址传参void print2(struct S* ps)&#123; printf(&quot;%d\n&quot;,ps-&gt;num);&#125;int main()&#123; print1(s); print2(&amp;s); return 0;&#125; 函数传参的时候参数是需要压栈的，如果传递结构体对象的时候，结构体过大，压栈时系统开销大，会导致性能下降，所以选择传址 结构体内存对齐 结构体的内存对齐是拿空间换取时间的做法 结构体的对齐规则 第一个成员在与结构体变量偏移量为0的地址处 其他成员变量要对齐到对齐数的整数倍的地址处。对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。VS中默认为8，Linux中默认为4 结构体总大小为最大对齐数的整数倍 如果嵌套了结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;struct S1&#123; char c1; int i; char c2;&#125;;struct S2&#123; char c1; char c2; int i;&#125;;struct S3&#123; double d; char c; int i;&#125;;//结构体的嵌套struct S4&#123; char c1; struct S3 s3; double d;&#125;;int main()&#123; printf(&quot;%d\n&quot;, sizeof(struct S1)); printf(&quot;%d\n&quot;, sizeof(struct S2)); printf(&quot;%d\n&quot;, sizeof(struct S3)); printf(&quot;%d\n&quot;, sizeof(struct S4)); return 0;&#125; 结果：image 这里只对S4进行分析 如图： 在设计结构体的时候，我们既要满足对其又要节省空间，所以让占用空间小的成员尽量集中在一起 位段 位段的声明与结构体类似，但有两处不同 位段的成员必须是int、unsigned int、signed int 位段的成员名后面有一个冒号和一个数字 123456789struct A&#123; int _a:2; int _b:5; int _c:10; int _d:30;&#125;;printf(&quot;%d\n&quot;,sizeof(struct A)); //8 冒号后边的数字为比特位 接下来分析下位段的空间是如何开辟的 1234567891011121314151617181920#include &lt;stdio.h&gt;struct S&#123; char a : 3; char b : 4; char c : 5; char d : 4;&#125;;int main()&#123; struct S s = &#123;0&#125;; s.a = 10; s.b = 12; s.c = 3; s.d = 4; printf(&quot;%d\n&quot;,sizeof(struct S));//3 return 0;&#125; 如图：所示 [ ] 位段的内存分配 位段的成员可以是int、unsigned int、signed int或者是char类型 位段设计很多不确定因素，且是不跨平台的，注意可移植程序避免使用位段 [ ] 位段的跨平台问题 int位段被当成有符号还是无符号数不确定 位段中最大位的数目不确定。（16位机器最大16,32位机器最大32） 位段中的成员在内存中从左向右还是从右向左分配未定义 当一个结构包含两个位段，第二个位段成员比较大，无法容纳第一个位段剩余位时，舍弃剩余位还是利用剩余位，不确定 枚举（一一列举）1234567891011enum Day&#123; //枚举常量 MON, TUE, WED, THUR, FRI, SAT, SUN&#125;; 枚举常量的值默认从0开始，依次递增1，在定义时也可以赋初值 123456enum Color&#123; RED = 1, GREEN = 3, BLUE = 4&#125;; 枚举的优点 增加代码的可读性和可维护性 枚举有类型检查，更加严谨（只能拿枚举常量给枚举变量赋值，这样不会出现类型的差异） 防止命名污染，便与调试，一次可定义多个常量 联合（共用体） 联合类型的定义 联合类型的定义的成员共用同一块空间 1234567union Un&#123; char c; int i;&#125;;printf(&quot;%d\n&quot;,sizeof(union Un));//4 12345678910//联合的特点：成员共用同一块空间union Un&#123; int i; char c;&#125;;union Un un;printf(&quot;%d\n&quot;,&amp;(un.i));printf(&quot;%d\n&quot;,&amp;(un.c)); 123 联合大小的计算 联合的大小至少是最大成员的大小 当最大成员大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍 12345678910111213union U1&#123; char c[5]; int i;&#125;;union U2&#123; short c[7]; int i;&#125;;printf(&quot;%d\n&quot;,sizeof(union U1));//8printf(&quot;%d\n&quot;,sizeof(union U2));//16 联合的一些应用 判断大小端存储 1234567891011int check_sys()&#123; union &#123; int i; char c; &#125;un; un.i = 1; return un.c; //返回1小端存储，返回0大端存储&#125; 联合和结构体的使用（IP地址） 12345678910111213141516171819//将long类型的IP地址转换为点分10进制的表示形式union ip_addr&#123; unsigned long addr; struct &#123; unsigned char c1; unsigned char c2; unsigned char c3; unsigned char c4; &#125;ip;&#125;;int main()&#123; union ip_addr my_ip; my_ip.addr = 123456789; printf(&quot;%d.%d.%d.%d\n&quot;,my_ip.ip.c4,my_ip.ip.c3,my_ip.ip.c2,my_ip.ip.c1); return 0;&#125;]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表的基本操作]]></title>
    <url>%2F2018%2F09%2F09%2F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[链表 本文中主要分析以下几个链表： 不带头节点的单链表、带头节点的双向循环链表 链表：一种链式存储的线性表，用一组地址任意的存储单元存放线性表的数据元素，称存储单元为一个节点 链表分类 1.单/双链表 2.带/不带头节点 3.循环/不循环链表 单链表 基本操作：初始化、销毁、插、删、查在删除和插入中分：头删/插、尾删/插、正常删/插 定义结构体 1234567typedef int DataType;typedef struct ListNode&#123; DataType data; struct ListNode* next;&#125; ListNode; 初始化 12345void ListInit(ListNode **ppfirst)&#123; assert(*ppfirst!=NULL); *ppfirst = NULL;&#125; 销毁 12345678910void DestroyList(ListNode **ppfirst)&#123; ListNode *next = *ppfirst; for(ListNode *cur = *ppfirst;cur!=NULL;cur = next) &#123; next = cur-&gt;next; free(cur); &#125; *ppfirst = NULL;&#125; 创建节点 123456789ListNode* CreatNode(DateType data)&#123; ListNode* newnode = (ListNode*)malloc(sizeof(ListNode)); assert(newnode); node-&gt;data = data; node-&gt;next = NULL; return newnode;&#125; 插入 分析正常情况：从堆上申请空间，更改ppfirst的值 特殊情况：*ppfirst == NULL 头插 12345678void ListPushFront(ListNode **ppfirst, DataType data)&#123; assert(ppfirst != NULL); ListNode* node = CreatNode(data); node-&gt;next = *ppfirst; *ppfirst = node;&#125; 尾插（遍历链表） 1234567891011121314151617void ListPushBack(ListNode **ppfirst, DataType data)&#123; ListNode* node = CreatNode(data); //特殊情况 链表为空 if(*ppfirst == NULL) &#123; *ppfirst = node; return; &#125; //正常情况 ListNode *cur = *ppfirst; while(cur != NULL) &#123; cur = cur-&gt;next; &#125; cur-&gt;next = node;&#125; 正常插入（中插） 分析 如果要插入的位置是第一个节点—&gt;调用头插 找到要插入的位置的前一个节点，插入 123456789101112131415161718void ListInsert(ListNode **ppfirst, ListNode *pos, DataType data)&#123; //pos是第一个节点 if(*ppfirst == pos) &#123; ListPushFront(ppfirst,data); return; &#125; //找到pos前一个节点 ListNode *cur = *ppfirst; while(cur-&gt;next != pos) &#123; cur = cur-&gt;next; &#125; ListNode *node = CreatNode(data); node-&gt;next = cur-&gt;next; cur-&gt;next = node;&#125; [ ] 删除 头删 分析 变量地址不为空 不能为空链表 12345678void ListPopFront(ListNode **ppfirst)&#123; assert(ppfirst != NULL); assert(*ppfirst != NULL); ListNode *del = *ppfirst; *ppfirst = del-&gt;next; free(del);&#125; 尾删 分析 cur-&gt;next-&gt;next == NULL 特殊：只有一个节点 123456789101112131415161718192021void ListPopBack(ListNode **ppfirst)&#123; assert(ppfirst != NULL); assert(*ppfirst != NULL); //只有一个节点 if((*ppfirst)-&gt;next == NULL) &#123; free(*ppfirst); *ppfirst = NULL; return; &#125; ListNode *cur = *ppfirst; ListNode *del; while(cur-&gt;next-&gt;next != NULL); &#123; cur = cur-&gt;next; &#125; del = cur-&gt;next; cur-&gt;next = NULL; free(del);&#125; 正常删除（中删） 分析 当要删除的是第一个节点时—&gt;头删 先找到要删除的节点的前一个节点，然后删除 1234567891011121314151617void ListEarse(ListNode **ppfirst, ListNode *pos)&#123; assert(ppfirst != NULL); assert(*ppfirst != NULL); if((*ppfirst)-&gt;next == pos) &#123; ListPopFront(ppfirst); return; &#125; ListNode *cur = *ppfirst; while(cur-&gt;next != pos) &#123; cur = cur-&gt;next; &#125; cur-&gt;next = pos-&gt;next; free(pos);&#125; 查找 分析 遍历链表 传值 123456789101112ListNode* ListFind(ListNode* first, DataType data)&#123; assert(first); for(ListNode *cur = first; cur != NULL; cur = cur-&gt;next) &#123; if(cur-&gt;data == data) &#123; return cur; &#125; &#125; return NULL;&#125; 双向带头循环链表 基本操作：初始化、销毁（删除带头节点）、清空（保留带头节点）、插、删在删除和插入中分：头删/插、尾删/插、正常删/插 定义结构体 123456typedef struct DListNode&#123; int data; struct DListNode *prev; struct DListNode *next;&#125; DListNode; 初始化 123456789void DListInit(DListNode **ppHead)&#123; assert(ppHead != NULL); DListNode *pHead = (DListNOde*)malloc(sizeof(DListNode)); pHead-&gt;prev = pHead; pHead-&gt;next = pHead; *ppHead = pHead;&#125; 清空链表 123456789101112void DListClear(DListNode *pHead)&#123; DListNode *cur = pHead-&gt;next; DListNode *next; while(cur != pHead) &#123; next = cur-&gt;next; free(cur); &#125; pHead-&gt;next = pHead; pHead-&gt;prev = pHead;&#125; 销毁 1234567void DListDestroy(DListNode **ppHead)&#123; assert(ppHead != NULL); DListClear(*ppHead); free(*ppHead); *ppHead = NULL;&#125; [ ] 插入 正常插入 1234567891011void DListInsert(DListNode *pHead, DListNode *pos, int data)&#123; (void)pHead;//仅仅是为了防止编译警告 DListNode *node = (DListNOde*)malloc(sizeof(DListNode)); node-&gt;data = data; node-&gt;prev = pos-&gt;prev; node-&gt;next = pos; pos-&gt;prev-&gt;next = node; pos-&gt;prev = node;&#125; 头插 1234void DListPushFront(DListNode *pHead, int data)&#123; DListInsert(pHead, pHead-&gt;next, data);&#125; 尾插 1234void DListPushBack(DListNode *pHead, int data)&#123; DListInsert(pHead,pHead,data);&#125; [ ] 删除 正常删除 123456789void DListErase(DListNode *pHead, DListNode *pos)&#123; (void)pHead; assert(pHead != NULL); pos-&gt;prev-&gt;next = pos-&gt;next; pos-&gt;next-&gt;prev = pos-&gt;prev; free(pos);&#125; 头删 1234void DListPopFront(DListNode *pHead)&#123; DListErase(pHead,pHead-&gt;next);&#125; 尾删 1234void DListPopBack(DListNode *pHead)&#123; DListErase(pHead, pHead-&gt;prev);&#125;]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
